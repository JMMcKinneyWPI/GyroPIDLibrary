#pragma config(Sensor, in1,    gyrosensor,     sensorAnalog)
#pragma config(Sensor, in2,    armPot,         sensorAnalog)
#pragma config(Motor,  port1,           arm1,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port10,          arm2,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"
#include "../libGyro/NERD_Gyro.c"
#include "../libPID/NERD_PID.c"
#include "../libToolkit/Truespeed.h"

#define SET_ANGLE 90
#define ARM_LOW 1000
#define ARM_HIGH 3000

Gyro gyro;
PID gyroPID;
PID armPID;

/**
 * power left drive motors
 */
void
driveL(int val){
	val = abs(val) > 127 ? 127 * val/abs(val) : val;
	motor[port2] = val;
}

/**
 * power right drive motors
 *
 * @param val value to set drive to
 */
void
driveR(int val){
	val = abs(val) > 127 ? 127 * val/abs(val) : val;
	motor[port3] = val;
}

/**
 * gyro turn to target angle
 *
 * @param fTarget target value of gyro turn (in degrees)
 */
void
gyroTurn(float fTarget){
	if(abs(fTarget) < 40)
		pidInit(gyroPID, 3.0, 0.0, 0.15, 3.0, 30.0);
	bool bAtGyro = false;
	long liAtTargetTime = nPgmTime;
	long liTimer = nPgmTime;
	float fGyroAngle = 0;

	while(!bAtGyro){
		//Calculate the delta time from the last iteration of the loop
		float fDeltaTime = (float)(nPgmTime - liTimer)/1000.0;
		//Reset loop timer
		liTimer = nPgmTime;

		fGyroAngle += gyroGetRate(gyro) * fDeltaTime;

		//Calculate the output of the PID controller and output to drive motors
		float driveOut = pidCalculate(gyroPID, fTarget, fGyroAngle);
		driveL(-driveOut);
		driveR(driveOut);

		//Stop the turn function when the angle has been within 3 degrees of the desired angle for 350ms
		if(abs(fTarget - fGyroAngle) > 3)
			liAtTargetTime = nPgmTime;
		if(nPgmTime - liAtTargetTime > 350){
			bAtGyro = true;
			driveL(0);
			driveR(0);
		}
	}

	//Reinitialize the PID constants to their original values in case they were changed
	pidInit(gyroPID, 2, 0, 0.15, 2, 20.0);
}

/**
 * Calibrate gyro and initialize PID controller
 */
void
pre_auton(){
	//Allow gyro to settle and then init/calibrate (Takes a total of around 2 seconds)
	delay(1100);
	gyroInit(gyro, in1);

	pidInit (armPID, 0.5, 1, 0.02, 5.0, 300.0);

	/*Initialize PID controller for gyro
	 * kP = 2, kI = 0, kD = 0.15
	 * epsilon = 0
	*/
	//pidInit(gyroPid, 2, 0, 0.15, 2, 20.0);
}

task
autonomous(){
	//Turn the robot by the desired angle
	//gyroTurn(SET_ANGLE);
}

float fGyroAngle;

task
usercontrol(){
	//delay(1100);
	//gyroInit(gyro, in1);

	long liTimer = nPgmTime;
	long printTimer = nPgmTime;
	fGyroAngle = 0;
	while (true) {
		float fDeltaTime = (nPgmTime - liTimer) / 1000.0;
		liTimer = nPgmTime;

		fGyroAngle -= gyroGetRate(gyro)* fDeltaTime;

		//float setPoint = 1000 + fGyroAngle * 11.375;

		//if (setPoint < ARM_LOW) setPoint = 1000;
		//if (setPoint > ARM_HIGH) setPoint = ARM_HIGH;

		float out = pidCalculate (armPID, 2000, SensorValue (in2));

		motor (port1) = sgn (out) * TrueSpeed [(int) abs (out)];
		motor (port10) = motor (port1);

		if (nPgmTime - printTimer >= 100) {
			printTimer = nPgmTime;
			writeDebugStreamLine ("Angle: %0.4f\tPID Output: %0.4f", fGyroAngle, out);
		}

		delay (1);
	}
}
